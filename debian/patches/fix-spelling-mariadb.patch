Forwarded: no
Author: Otto Kekäläinen <otto@debian.org>
Date: Sun, 10 Mar 2024 16:56:13 +0000
Subject: [PATCH] Fix misc spelling in MariaDB Server repository

--- a/storage/connect/odbconn.cpp
+++ b/storage/connect/odbconn.cpp
@@ -281,7 +281,7 @@ static CATPARM *AllocCatInfo(PGLOBAL g,
 		cap->Status = (UWORD *)PlugSubAlloc(g, NULL, m * sizeof(UWORD));
 
 	} catch (int n) {
-		htrc("Exeption %d: %s\n", n, g->Message);
+		htrc("Exception %d: %s\n", n, g->Message);
 		cap = NULL;
 	} catch (const char *msg) {
 		htrc(g->Message, msg);
--- a/extra/mariabackup/innobackupex.cc
+++ b/extra/mariabackup/innobackupex.cc
@@ -188,7 +188,7 @@ enum innobackupex_options
 	OPT_DATABASES,
 	OPT_DECOMPRESS,
 
-	/* options wich are passed directly to xtrabackup */
+	/* options which are passed directly to xtrabackup */
 	OPT_CLOSE_FILES,
 	OPT_COMPACT,
 	OPT_COMPRESS,
@@ -447,7 +447,7 @@ static struct my_option ibx_long_options
 	{"startup-wait-timeout", OPT_LOCK_WAIT_TIMEOUT,
          "This option specifies time in seconds that mariadb-backup should wait for "
          "BACKUP STAGE START to complete. BACKUP STAGE START has to wait until all "
-         "currently running queries using explicite LOCK TABLES has ended. "
+         "currently running queries using explicit LOCK TABLES has ended. "
          "If there are still such queries when the timeout expires, mariadb-backup "
          "terminates with an error. Default is 0, in which case mariadb-backup waits "
          "indefinitely for BACKUP STAGE START to finish",
--- a/extra/mariabackup/xtrabackup.cc
+++ b/extra/mariabackup/xtrabackup.cc
@@ -217,7 +217,7 @@ uint xtrabackup_compress = FALSE;
 uint xtrabackup_compress_threads;
 ulonglong xtrabackup_compress_chunk_size = 0;
 
-/* sleep interval beetween log copy iterations in log copying thread
+/* sleep interval between log copy iterations in log copying thread
 in milliseconds (default is 1 second) */
 ulint xtrabackup_log_copy_interval = 1000;
 static ulong max_buf_pool_modified_pct;
@@ -1600,11 +1600,11 @@ struct my_option xb_client_options[]= {
      GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},
 
     {"rsync", OPT_RSYNC,
-     "Obsolete depricated option",
+     "Obsolete deprecated option",
      &ignored_option, &ignored_option,  0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},
 
     {"no-backup-locks", OPT_NO_BACKUP_LOCKS,
-     "Obsolete depricated option",
+     "Obsolete deprecated option",
      &ignored_option, &ignored_option,  0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},
 
     {"force-non-empty-directories", OPT_FORCE_NON_EMPTY_DIRS,
@@ -1732,7 +1732,7 @@ struct my_option xb_client_options[]= {
     {"startup-wait-timeout", OPT_LOCK_WAIT_TIMEOUT,
      "This option specifies time in seconds that mariadb-backup should wait for "
      "BACKUP STAGE START to complete. BACKUP STAGE START has to wait until all "
-     "currently running queries using explicite LOCK TABLES has ended. "
+     "currently running queries using explicit LOCK TABLES has ended. "
      "If there are still such queries when the timeout expires, mariadb-backup "
      "terminates with an error. Default is 0, in which case mariadb-backup waits "
      "indefinitely for BACKUP STAGE START to finish",
@@ -5642,7 +5642,7 @@ void CorruptedPages::backup_fix_ddl(ds_c
 	}
 
 	/* Mariabackup doesn't detect any FILE_OP for the deferred
-	tablespace. There is a possiblity that page0 could've
+	tablespace. There is a possibility that page0 could've
 	been corrupted persistently in the disk */
 	for (auto space_name: defer_space_names) {
 		if (!check_if_skip_table(space_name.c_str())) {
--- a/support-files/mysql.server.sh
+++ b/support-files/mysql.server.sh
@@ -194,7 +194,7 @@ su_kill() {
 
 #
 # Read defaults file from 'basedir'.   If there is no defaults file there
-# check if it's in the old (depricated) place (datadir) and read it from there
+# check if it's in the old (deprecated) place (datadir) and read it from there
 #
 
 extra_args=""
--- a/sql/opt_subselect.cc
+++ b/sql/opt_subselect.cc
@@ -6886,7 +6886,7 @@ bool JOIN::choose_subquery_plan(table_ma
         add("rows", inner_record_count_1).
         add("materialization_cost", materialize_strategy_cost).
         add("in_exist_cost", in_exists_strategy_cost).
-        add("choosen", strategy);
+        add("chosen", strategy);
     }
 
     DBUG_PRINT("info",
@@ -6924,7 +6924,7 @@ bool JOIN::choose_subquery_plan(table_ma
     {
       Json_writer_object trace_wrapper(thd);
       Json_writer_object trace_subquery(thd, "subquery_plan_revert");
-      trace_subquery.add("choosen", "in_to_exists");
+      trace_subquery.add("chosen", "in_to_exists");
     }
   }
 
--- a/sql/sql_select.cc
+++ b/sql/sql_select.cc
@@ -14670,7 +14670,7 @@ void JOIN::drop_unused_derived_keys()
       }
       /*
         We dropped all keys except the chosen one and unique keys.
-        The choosen one is stored as the first key (number 0).
+        The chosen one is stored as the first key (number 0).
       */
       tab->ref.key= 0;
     }
